#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NoireLib.SourceGenerators;

[Generator]
public sealed class NoireDatabaseGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsCandidateClass(s),
                static (ctx, _) => GetSemanticTarget(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(classDeclarations, Execute!);
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax c && c.Members.OfType<PropertyDeclarationSyntax>().Any(p => p.AttributeLists.Count > 0);
    }

    private static ModelInfo? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

        if (classSymbol == null)
            return null;

        if (!InheritsNoireDbModelBase(classSymbol))
            return null;

        var properties = new List<PropertyInfo>();
        foreach (var propertyDeclaration in classDeclaration.Members.OfType<PropertyDeclarationSyntax>())
        {
            if (propertyDeclaration.AttributeLists.Count == 0)
                continue;

            if (!propertyDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword))
                continue;

            if (!IsPartialAutoProperty(propertyDeclaration))
                continue;

            if (context.SemanticModel.GetDeclaredSymbol(propertyDeclaration) is not IPropertySymbol propertySymbol)
                continue;

            var columnAttribute = propertySymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "NoireDbColumnAttribute");

            if (columnAttribute == null)
                continue;

            var columnName = GetColumnName(columnAttribute, propertySymbol.Name);
            var typeName = propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            properties.Add(new PropertyInfo(propertySymbol.Name, typeName, columnName, propertySymbol.DeclaredAccessibility, propertySymbol.IsStatic));
        }

        if (properties.Count == 0)
            return null;

        return new ModelInfo(
            classSymbol.ContainingNamespace.ToDisplayString(),
            classSymbol.Name,
            classSymbol.DeclaredAccessibility,
            classSymbol.IsSealed,
            classSymbol.IsAbstract,
            properties);
    }

    private static bool InheritsNoireDbModelBase(INamedTypeSymbol classSymbol)
    {
        var baseType = classSymbol.BaseType;
        while (baseType != null)
        {
            if (baseType.Name is "NoireDbModelBase" or "NoireDbModelBase`1")
                return true;

            baseType = baseType.BaseType;
        }

        return false;
    }

    private static bool IsPartialAutoProperty(PropertyDeclarationSyntax propertyDeclaration)
    {
        if (propertyDeclaration.AccessorList == null)
            return false;

        foreach (var accessor in propertyDeclaration.AccessorList.Accessors)
        {
            if (accessor.Body != null || accessor.ExpressionBody != null)
                return false;
        }

        return true;
    }

    private static string GetColumnName(AttributeData attribute, string defaultName)
    {
        if (attribute.ConstructorArguments.Length > 0 && attribute.ConstructorArguments[0].Value is string name && !string.IsNullOrWhiteSpace(name))
            return name;

        return defaultName;
    }

    private void Execute(SourceProductionContext context, ModelInfo? modelInfo)
    {
        if (modelInfo == null)
            return;

        var source = GenerateSource(modelInfo);
        context.AddSource($"{modelInfo.Name}.NoireDbColumns.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private string GenerateSource(ModelInfo modelInfo)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {modelInfo.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"{BuildClassDeclaration(modelInfo)}");
        sb.AppendLine("{");

        foreach (var property in modelInfo.Properties)
        {
            sb.AppendLine($"{BuildPropertyDeclaration(property)}");
            sb.AppendLine("{");
            sb.AppendLine($"get => GetColumn<{property.TypeName}>(\"{property.ColumnName}\");");
            sb.AppendLine($"set => SetColumn(\"{property.ColumnName}\", value);");
            sb.AppendLine("}");
            sb.AppendLine();
        }

        sb.AppendLine("}");
        sb.AppendLine("}");

        return FormatCSharpCode(sb.ToString());
    }

    private static string BuildClassDeclaration(ModelInfo modelInfo)
    {
        var modifiers = new List<string>
        {
            GetAccessibility(modelInfo.Accessibility)
        };

        if (modelInfo.IsAbstract)
            modifiers.Add("abstract");

        if (modelInfo.IsSealed)
            modifiers.Add("sealed");

        modifiers.Add("partial");

        return $"{string.Join(" ", modifiers)} class {modelInfo.Name}";
    }

    private static string BuildPropertyDeclaration(PropertyInfo property)
    {
        var modifiers = new List<string>
        {
            GetAccessibility(property.Accessibility)
        };

        if (property.IsStatic)
            modifiers.Add("static");

        modifiers.Add("partial");

        return $"{string.Join(" ", modifiers)} {property.TypeName} {property.Name}";
    }

    private static string GetAccessibility(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            Accessibility.Internal => "internal",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => "internal"
        };
    }

    private string FormatCSharpCode(string code)
    {
        var tree = CSharpSyntaxTree.ParseText(code);
        var root = tree.GetRoot().NormalizeWhitespace();
        return root.ToFullString();
    }

    private class ModelInfo
    {
        public string Namespace { get; }
        public string Name { get; }
        public Accessibility Accessibility { get; }
        public bool IsSealed { get; }
        public bool IsAbstract { get; }
        public List<PropertyInfo> Properties { get; }

        public ModelInfo(string @namespace, string name, Accessibility accessibility, bool isSealed, bool isAbstract, List<PropertyInfo> properties)
        {
            Namespace = @namespace;
            Name = name;
            Accessibility = accessibility;
            IsSealed = isSealed;
            IsAbstract = isAbstract;
            Properties = properties;
        }
    }

    private class PropertyInfo
    {
        public string Name { get; }
        public string TypeName { get; }
        public string ColumnName { get; }
        public Accessibility Accessibility { get; }
        public bool IsStatic { get; }

        public PropertyInfo(string name, string typeName, string columnName, Accessibility accessibility, bool isStatic)
        {
            Name = name;
            TypeName = typeName;
            ColumnName = columnName;
            Accessibility = accessibility;
            IsStatic = isStatic;
        }
    }
}
